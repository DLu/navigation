


unsigned int worldToIndex(Costmap2D& map, double wx, double wy){
  unsigned int mx, my;
  map.worldToMap(wx, wy, mx, my);
  return map.getIndex(mx, my);
}

void indexToWorld(Costmap2D& map, unsigned int index, double& wx, double& wy){
  unsigned int mx, my;
  map.indexToCells(index, mx, my);
  map.mapToWorld(mx, my, wx, wy);
}


/**
 * Within a certian radius of the robot, the cost map most propagate obstacles. This
 * is to avoid a case where a hit on a far obstacle clears inscribed radius around a
 * near one.
 */

TEST(costmap, testTrickyPropagation){
  const unsigned char MAP_HALL_CHAR[10 * 10] = {
    0,   0, 0,   0,   0, 0,   0, 0, 0, 0,
    254, 0, 0,   0,   0, 0,   0, 0, 0, 0,
    0,   0, 0,   0,   0, 0,   0, 0, 0, 0,
    0,   0, 0,   254, 0, 0,   0, 0, 0, 0,
    0,   0, 0,   0,   0, 0,   0, 0, 0, 0,
    0,   0, 0,   0,   0, 0,   0, 0, 0, 0,
    0,   0, 0,   0,   0, 254, 0, 0, 0, 0,
    0,   0, 0,   0,   0, 254, 0, 0, 0, 0,
    0,   0, 0,   0,   0, 0,   0, 0, 0, 0,
    0,   0, 0,   0,   0, 0,   0, 0, 0, 0,
  };
  std::vector<unsigned char> MAP_HALL;
  for (int i = 0; i < 10 * 10; i++) {
    MAP_HALL.push_back(MAP_HALL_CHAR[i]);
  }

  Costmap2D map(GRID_WIDTH, GRID_HEIGHT, RESOLUTION, 0.0, 0.0, ROBOT_RADIUS, ROBOT_RADIUS, ROBOT_RADIUS, 
      100.0, MAX_Z, 100.0, 1, MAP_HALL, THRESHOLD);


  //Add a dynamic obstacle
  pcl::PointCloud<pcl::PointXYZ> c2;
  c2.points.resize(3);
  //Dynamic obstacle that raytaces.
  c2.points[0].x = 7.0;
  c2.points[0].y = 8.0;
  c2.points[0].z = 1.0;
  //Dynamic obstacle that should not be raytraced the
  //first update, but should on the second.
  c2.points[1].x = 3.0;
  c2.points[1].y = 4.0;
  c2.points[1].z = 1.0;
  //Dynamic obstacle that should not be erased.
  c2.points[2].x = 6.0;
  c2.points[2].y = 3.0;
  c2.points[2].z = 1.0;

  geometry_msgs::Point p2;
  p2.x = 0.5;
  p2.y = 0.5;
  p2.z = MAX_Z;

  Observation obs2(p2, c2, 100.0, 100.0);
  std::vector<Observation> obsBuf2;
  obsBuf2.push_back(obs2);

  map.updateWorld(0, 0, obsBuf2, obsBuf2);

  const unsigned char MAP_HALL_CHAR_TEST[10 * 10] = { 
    253, 254, 253,   0,   0,   0,   0,   0,   0,   0,
      0, 253,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0, 253,   0,   0,   0,   0,   0,
      0,   0,   0, 253, 254, 253,   0,   0,   0,   0,
      0,   0,   0,   0, 253,   0,   0, 253,   0,   0,
      0,   0,   0, 253,   0,   0, 253, 254, 253,   0,
      0,   0, 253, 254, 253,   0,   0, 253, 253,   0,
      0,   0,   0, 253,   0,   0,   0, 253, 254, 253,
      0,   0,   0,   0,   0,   0,   0,   0, 253,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  };

  
  for (int i = 0; i < 10 * 10; i++) {
    ASSERT_EQ(map.getCost(i / 10, i % 10), MAP_HALL_CHAR_TEST[i]);
  }

  pcl::PointCloud<pcl::PointXYZ> c;
  c.points.resize(1);
  //Dynamic obstacle that raytaces the one at (3.0, 4.0).
  c.points[0].x = 4.0;
  c.points[0].y = 5.0;
  c.points[0].z = 1.0;

  geometry_msgs::Point p3;
  p3.x = 0.5;
  p3.y = 0.5;
  p3.z = MAX_Z;

  Observation obs3(p3, c, 100.0, 100.0);
  std::vector<Observation> obsBuf3;
  obsBuf3.push_back(obs3);

  map.updateWorld(0, 0, obsBuf3, obsBuf3);

  const unsigned char MAP_HALL_CHAR_TEST2[10 * 10] = { 
    253, 254, 253,   0,   0,   0,   0,   0,   0,   0,
      0, 253,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0, 253,   0,   0,   0,   0,
      0,   0,   0,   0, 253, 254, 253, 253,   0,   0,
      0,   0,   0, 253,   0, 253, 253, 254, 253,   0,
      0,   0, 253, 254, 253,   0,   0, 253, 253,   0,
      0,   0,   0, 253,   0,   0,   0, 253, 254, 253,
      0,   0,   0,   0,   0,   0,   0,   0, 253,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  };

  
  for (int i = 0; i < 10 * 10; i++) {
    ASSERT_EQ(map.getCost(i / 10, i % 10), MAP_HALL_CHAR_TEST2[i]);
  }
}

